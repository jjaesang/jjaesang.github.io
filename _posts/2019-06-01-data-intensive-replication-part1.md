---
layout: post
title:  "[Data-Intensive] Ch5. 복제"
date: 2019-06-01 17:15:12
categories: Data-Intensive-Application 
author : Jaesang Lim˚
tag: Data-Intensive-Application 
cover: "/assets/instacode.png"
---

## 저장소와 검색
'데이터 중심 애플리케이션 설계'를 읽고 정리하고자함

- 복제는 3가지 접근 방식으로 나눠서 정리할 예정
1. 도입 및 단일 리더 복제
2. 다중 리더 복제
3. 리더 없는 복제

- 이 글은 '복제에 대한 전반적인 내용, 도입부'와 '단일 리더 복제' 방법에 대해 다룰 것

---

## 복제 ( Replication )

복제 란?
- 네트워그로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것을 의미

복제가 필요한 이유

1. 지리적으로 사용자와 가까게 데이터를 유지해  **지연시간**을 줄임
2. 시스템의 일부가 장애가 발생하더라도 지속적으로 동작할 수 있게 **가용성**을 높임
3. 읽기 질의를 제공하는 장비의 수를 확장해 **처리량**을 늘림
- 즉, latency, Avaliablilty, Throughtput 측면에서 도움을 준다고 생각할 수 있음

복제의 어려움
- 복제중인 데이터가 시간이 지나도 변경되지 않으면 복제는 간단함
- 하지만, 복제된 데이터의 **변경**처리해야함

## 리더 기반 복제 (Leader-based replication)

<img width="736" alt="스크린샷 2019-06-01 오후 6 09 14" src="https://user-images.githubusercontent.com/12586821/58746372-7e472d00-8498-11e9-8c78-14a596dce9e7.png">

- 복사본을 저장하는 각 노드를 복제 서버(replica) 라고함
- 복제 서버 중 하나를 리더, 마스터, 프라이머리 라고함

- 클라이언트가 데이터베이스에 쓸 때, 요청은 리더에게 보내야함
- 요청은 받은 리더는 먼저 로컬 저장소에 새로운 데이터를 기록
- 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다, 데이터 변경을 복제로그(replication log)나 변경 스트림(change stream)의 일부로 팔로우에게 전송
- 각 팔로워는 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해, 데이터베이스의 로컬 복사본을 갱신

- 클라이언트의 읽기 요청은 리더 또는 임의의 팔로워에게 질의할 수 있음
- 쓰기는 리더에게만 허용함

### 1. 동기식 대 비동기식 복제 
<img width="768" alt="스크린샷 2019-06-01 오후 6 19 10" src="https://user-images.githubusercontent.com/12586821/58746492-c7e44780-8499-11e9-8554-f31ef481cdb2.png">


동기식 복제
- 장점
> - 팔로워가 리더와 일관성 있게 최신 데이터 복제본을 가지는 것을 보장함
- 단점
> - 팔로워가 응답하지 않으면 쓰기가 처리될 수 없음
> - 리더는 모든 쓰기를 block하고 동기 복제 서버가 다시 사용할 수 있을 때까지 대기해야함

- 즉 모든 팔로워가 동기식 상황이라면, 임의의 한 노드의 장애는 전체 시스템을 멈추게함
> - 그래서 일반적으로 반동기식(semi-synchronous)을 사용
> > - 팔로워 하나는 동기식, 나머지는 비동기식으로 처리하는 방법


새로운 팔로워 설정

- 복제 서버 수를 늘리거나, 장애 노드의 대체를 위해 새로운 팔로워을 설정해야함
- 그렇다면, 새로운 팔로워가 리더의 복제본을 정확히 가지고 있는지 어떻게 보장할까?

1. 전체 데이터베이스를 잠그지 않고, 리더의 데이터베이스 snapshot을 가져옴
2. snapshot을 새로운 노드에 복사함
3. 팔로워는 리더에 연결해, snapshot 이후 발생한 모든 데이터 변경을 요청
4. 팔로워가 snapshot 이후 데이터 변경의 미처리분(backlog)를 다처리하면 따라잡았다고 함


노드 중단 처리 (= 고가용성을 달성하는 방법)

팔로워 장애 : 따라잡기 복구
1. 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관함
2. 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아냄
3. 팔로워는 리더에 연결해, 끊어진 동안 발생한 데이터 변경을 모두 요청

리더 장애 : 장애 복구

장애복구(failover) 과정
1. 팔로워 중 하나를 새로운 리더로 승격해야함
2. 클라이언트는 새로운 리더로 쓰기요청을 할 수 있게 재설정도 해야함
3. 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야함 

자동 장애복구 과정
1. 리더가 장애인지 판단
> - timeout
2. 새로운 리더 선책
> - 선출과정(리더가 나머지 복제 서버의 대다수에 의해 선택)또는 제어 노드(controller node)에 의해 리더를 임명
> - 이전 리더의 최신 데이터 변경사항을 가진 복제서버가 일반적인 새로운 리더의 후보
3. 새로운 리더 사용을 위해 시스템 재설정

장애복구 과정의 문제가 될만한 사항들
1. 데이터 유실
> - 비동기식 복제를 사용한다면, 새로운 리더는 이전 리더가 실패하기 전의 쓰기 요청의 일부를 수신 못 할수있음
> - 새로운 리더가 선출되고, 이전 리더가 다시 클러스터에 추가된다면?
> - 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 방법이 있으나, 이는 내구성(Durability)의 문제를 야기함

2. 쓰기를 폐기하면, 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야한다면 위험함
> - 실제 github에서 발생한 사고로, 일부 개인 데이터가 잘못된 사용자에게 공개되었음
> - 유효하지 않은,out-of-date mysql 팔로워가 리더로 승격되었음
> - primary key를 자동증가카운터로 사용했지만, 새로운 리더의 카운터는 이전 리더보다 뒤쳐져 있어, 이전 리더가 예전에 할당한 primary key를 재사용함
> - 이 primary key는 redis 저장에도 사용해, mysql과 redis간 불일치 발생

3. 스플릿 브레인(split brain)
> - 두 노드가 모두 자신이 리더라고 생각하는 상황
> - 두 리더가 쓰기를 받으면서 충돌 해소하는 과정을 거치지 않으면, 데이터 유실 또는 데이터가 오염될 수 있음
> - 일부 시스템은 두 리더가 감지되면 한 노드를 죽이는 매커니즘이 있음
> > - 이를 fencing, 노드를 확실하게 죽이기(Shoot The Other Node In The Head,STONITH)라고도 함
> > - 하둡 NN에 fencing 방법을 사용함

4. timeout 선정의 어려움

