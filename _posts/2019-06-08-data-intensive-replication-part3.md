---
layout: post
title:  "[Data-Intensive] Ch5. 복제 (Leaderless Replication)"
date: 2019-06-08 18:15:12
categories: Data-Intensive-Application 
author : Jaesang Lim˚
tag: Data-Intensive-Application 
cover: "/assets/instacode.png"
---

## 복제
'데이터 중심 애플리케이션 설계'를 읽고 정리하고자함

- 복제는 3가지 접근 방식으로 나눠서 정리할 예정
1. 도입 및 단일 리더 복제
2. 다중 리더 복제
**3. 리더 없는 복제**

- 이 글은 복제에 대한 **리더 없는 복제(Leaderless Replication)** 방법에 대해 다룰 것

---

## 리더 없는 복제

- 일부 데이터 저장소는 리더의 개념을 버리고, **모든 복제 서버가 클라이언트로부터 쓰기를 직접받을 수 있게 허용**하는 접근방식 사용
- 일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 요청함
- 반면, 코디네이터 노드가 클라이언트를 대신해 쓰기 요청을 직접 처리하기도 함
- 하지만, 리더와 달리 코디네이터는 쓰기의 순서를 보장하지 않음!

#### 노드가 다운됐을 때 데이터베이스에 쓰기

<img width="761" alt="스크린샷 2019-06-08 오후 6 34 20" src="https://user-images.githubusercontent.com/12586821/59145254-0fc81900-8a1c-11e9-93cb-bd309dc174d7.png">

- 3개의 복제 서버가 있다고 가정하고, 한 대 서버가 사용불가 상태일 때, 리더 기반 복제는 '장애 복구' 진행해야함
- 하지만 리더 없는 복제는 장애복구가 필요하지 않음

- 세 개의 복제 서버 중 두 개의 서버가 쓰기를 확인하면 충분하다고 가정하면, 클라이언트는 한 개의 쓰기가 놓친 사실을 그냥 무시해 버림
- 문제가 되었던 서버가 다시 온라인 상태로 들어오고, 클라이언트가 이 노드에서 읽으면, outdated 값을 얻을 수 있음

해결법
- 클라이언트가 하나의 복제서버가 아닌 병렬로 여러 노드에 읽기 요청을 보냄
- 여러 노드에서 받은 노드 중, 버전 값을 이용해 최신 내용인지 결정

---
#### 읽기 복구와 안티 엔트로피
- 복제의 궁극적인 목표는 **최종적으로 모든 데이터가 모든 복제서버에 복사된 것을 보장**해야함

사용 불가능 한 노드가 온라인 상태가 된 후, 누락된 쓰기를 어떻게 따라잡을 것인가?

1. 읽기 복구
- 클라이언트가 여러 노드에서 병렬로 읽고, outdated값을 반환한 해당 노드에게 최신값을 업데이트함
- 값을 자주 읽는 상황에 적합

2. 안티 엔트로피 처리
- 백그라운드 프로세스로, 복제 서버 간 데이터 차이를 지속적을 찾아냄
- 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사함
- 리더 기반 복제의 '로그 복제'와 달리, 엔트로피 처리는 특정 순서로 쓰기를 복사하기 때문에 복사되기 까지 지연이 발생할 수 있음

모든 시스템이 이 두가지 매커니즘을 구현하는 건아님
- 볼드모트는 안티 엔트로피를 처리하지 않음
> - 안티 엔트로피가 없으면, 읽기 복구는 애플리케이션이 값을 읽는 경우에만 수행되기 때문에, 거의 읽지 않는 일부 복제본에서 누락되 **내구성이 떨어짐**

---

#### 읽기와 쓰기를 위한 정족수 
<img width="761" alt="스크린샷 2019-06-08 오후 6 24 35" src="https://user-images.githubusercontent.com/12586821/59145180-4baeae80-8a1b-11e9-872c-f4941050155d.png">

---

#### 정족수 일관성의 한계

---

#### 최신성 모니터링

---

#### 느슨한 정족수와 암시된 핸드오프

---

#### 동시 쓰기 감지
<img width="761" alt="스크린샷 2019-06-08 오후 6 24 50" src="https://user-images.githubusercontent.com/12586821/59145181-4c474500-8a1b-11e9-866b-3936a8135b04.png">

---

#### 최종 쓰기 승리 (동시 쓰기 버리기)

---

#### 이전 발생 관계와 동시성

---

#### 이전 발생 관게 파악하기
<img width="761" alt="스크린샷 2019-06-08 오후 6 25 11" src="https://user-images.githubusercontent.com/12586821/59145182-4c474500-8a1b-11e9-97c4-462d402b69b5.png">
<img width="761" alt="스크린샷 2019-06-08 오후 6 25 36" src="https://user-images.githubusercontent.com/12586821/59145183-4c474500-8a1b-11e9-988e-6c1afd21f3a3.png">

---

#### 동시에 쓴 값 병합

---

#### 버전 벡터

