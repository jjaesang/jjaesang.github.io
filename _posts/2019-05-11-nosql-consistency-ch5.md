---
layout: post
title:  "[NoSQL] Ch5. 일관성"
date: 2019-05-11 18:15:12
categories: NoSQL 
author : Jaesang Lim˚
tag: NoSQL
cover: "/assets/instacode.png"
---

## 일관성 (Consistency)

'빅데이터 세상으로 떠나는 간결한 안내서 NoSQL'를 읽고 정리하고자함

---

### 요점 정리

- 쓰기 충돌
  > - 투 클라이언트가 동시에 같은 데이터를 쓰려고 할 때 발생
- 읽기-쓰기 충돌
  > - 한 클라이언트가 쓰고 있는 도중에 다른 클리아온트가 비일관적 데이터를 읽을 때 발생
  
- 방지 방법 
  > 1. 비관적 방법 : 데이터 레코드에 잠금을 사용
  > 2. 낙관적 방법 : 충돌을 탐지해 해결
  
- 분산 시스템에 읽기-쓰기 충돌이 발생하는 것은 업데이트를 받았지만, 다른 노드는 받지 못한 시점이 있기 떄문
- 결과적 일관성
  > - 쓰기가 다른 모든 노드로 전파되는 어떤 시점에 시스템이 일관성 있는 상태가 된다는 뜻
- 클라이언트는 보통 자신이 쓴 것에 대한 일관성이 필요함
  > - 즉, 클라이언트가 어떤 값을 쓴 즉시 그 값을 읽을 수 있어야 함
  > - 읽기와 쓰기가 다른 노드에서 수행된다면 이를 제공하기 어려울 수 있음

- 좋은 일관성을 얻으려면, 데이터 연산에 많은 노드가 관여해야 하지만, 이렇게 되면 지연이 길어짐
- 따라서 보통은 일관성과 지연 사이에 타협해야함 ( Consistency <> Latency TradeOff )

- CAP 정리는 네트워트 분단이 발생하는 경우, 데이터의 가용성과 일관성 사이에서 절청해야함을 알려줌
  > - 지속성 또한 지연과 절충할 수 있음
  > - 특히 데이터 복제에 실패하는 경우에도 서비스가 중단되지 않기를 바랄 경우 ( Durability <> Latency TradeOff )

- 강력한 일관성을 유지하려고 모든 복제본에 접근할 필요는 없다
  > - 충분한 정족수(quorum)만 채우면 
  
---

클러스터 지향 NoSQL 데이터베이스로 이동하면서 생긴 가장 큰 변화는 '일관성'에 대한 생각
- 'CAP 정리'나 '결과적 일관성' 같은 용어도 등장
- 무엇이든 만들기 시작하면 시스템에 '어떤 종류의 일관성'이 필요한지 생각해야함

### 1. 업데이트 일관성 ( 쓰기 충돌 write-write conflict )

- 쓰기 충돌 (write-write conflict)
> - 여러 사람이 동시에 같은 데이터 항목을 업데이트하는 문제

- 쓰기 요청이 서버에 도달하면, 이 요청을 직렬화해 하나를 먼저 적용하고 그 다음 다른 하나를 적용
> - 즉, 직렬화한다는 것은 '순서대로 정렬해 일렬로 세움' 이라고 생각할 수 있음

- 두명의 사람 M,P가 동시에 전화번호를 각각 다른 형식으로 업데이트 했다고 가
- 동시성 제어가 없다면, M의 업데이트는 적용된 즉시, P의 업데이트로 덮어쓰일 것
- 이 경우 M의 것은 '업데이트 손실(lost update)'이 될 수 있고, 이 상황은 일관성이 깨진 것으로 볼 수 있음
> - P의 업데이트가 M의 업데이트 이전의 상태에 근거하고 있으면서 M의 업데이트 이후에 적용되었기 때문

- 동시성 상황에서 일관성을 유지하는 두가지 방법
1. 비관적 방법
2. 낙관적 방법

1. 비관적 방법
> - 충돌이 발생하는 것을 방지하는 방식으로 동작
> - 쓰기 잠금(write lock)
> - 값을 변경하려면 먼저 잠금을 얻어야하고, 한번에 한 클라이언트만 잠금을 얻을 수 있음을 시스템이 보장함
> - 위의 상황에서는 M 요청만 성공하고, P는 이후 수정을 다시 시도할지 경정하기 전에 M이 업데이트한 결과를 보게 됌

2. 낙관적 방법
> - 충돌이 발생하도록 놔두고 충돌이 발생하면 이를 탐지해 적절한 조치를 취함
> - 클라이언트가 업데이트를 하기 전에 자신이 마지막으로 읽은 시점 이후로 값이 변경되었지는 검사하는 조건적 업데이트(conditional update) 사용하는 것
> - M의 업데이트는 성공하지만 P의 업데이트는 실패하고, P는 에러를 보고 값을 다시 확인 후 업데이트 계속 진행할지 결정
> - 두 업데이트를 모두 저장한 다음 충돌이 발생했다고 표시하는 경우도 있음
> > - 버전관리 시스템에서 익숙한 방법, 두 업데이트를 병합해야하고, 사용자에게 두 업데이트를 보여주고 정리하게끔 함

- 두 방법 모두 업데이트를 일관적으로 '직렬화'하는 것에 의존
- 단일 서버에서는 이 작업이 명확하다, 그냥 하나를 고른 다음 다른 것을 고르면 됌

- 그러나, 피어-투-피어 복제처럼 서버가  한대 이상이라면, 두 노드가 업데이트를 다른 순서로 적용될 수 있고, 그 결과 각 노드마다 다른 데이터값이 있을 수 있음
- 분산 시스템에서 동시성을 말할 때는 보통, 모든 노드가 같은 순서로 연산을 적용하는 것이 보장되는 '순차적 일관성'을 뜻하는 것

- 동시성 프로그램에서는 기본적으로 '안정성'과 '응답성'사이에서 선택해야함
> - 안정성 : 업데이트 충돌같은 에러를 회피하는 것
> - 응답성 : 클라이언트에 빠르게 응답

- 비관적 접근법은 응답성을 저해하고, 비관적 동시성에서는 deadlock를 초래하는 일이 흔하고 이는 예방, 디버깅도 어려움
- 복제를 사용하면 쓰기 충돌이 일어날 확룰이 훨씬 높아짐!
> - 두 개 이상의 노드가 어떤 데이터에 대한 복사본을 가지고 있고 이 데이터를 독립적으로 업데이트할 수 있다면,
> - 충돌을 피하기 위해 특별한 조치를 취하지 않은 한 충돌이 발생할 것 

- 데이터에 대한 쓰기를 단일 노드에서 처리하면 업데이트 일관성 유지가 휠씬 쉬움
- 그래서 피어-투-피어 복제를 제외한 모든 모델이 '데이터에 대한 쓰기'는 단일 노드에서 처리함


### 2. 읽기 일관성
### 3. 일관성 완화
### 4. 지속성 완화
### 5. 정족수
