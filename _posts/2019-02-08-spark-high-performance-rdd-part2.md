---
layout: post
title:  "[HP-Spark] 스파크 병렬 연산 모델 : RDD Part 2"
date: 2019-02-10 18:15:12
categories: High-Performance-Spark 
author : Jaesang Lim
tag: Spark
cover: "/assets/spark.png"
---

## 스파크의 병렬 연산 모델: RDD
---

### RDD의 종류

- 스파크의 스칼라 API는 추상 클래스, RDD를 포함하여, 5가지 핵심 속성 뿐 아니라, map, collect 등 RDD에서 사용가능한 트랜스포메이션과 액션을 가지고 있음
> * 5가지 속성 ( partitions , iterator , dependency , partitioner, preferredLocation )
- 이외에 특별한 타입 RDD에만 정의함수들이 있음!
- DoubleRDDFunctions, PairRDDFunctions, OrderedRDDFunctions .. 
- mappedRDD, CoGroupedRDD, NewHadoopRDD , ShuffledRDD 등등
- 즉. 사실상 RDD 연산 또는 변형했을 때 return되는 RDD는 다양한 종류가 있다는 뜻. 


==각 RDD와 RDD Function해서는 코드 관련해서 한번 다 까는 글을 올릴 것이다!!!!==

### RDD의 함수들

- RDD에 정의되는 함수들에는 2가지 타입만 존재 
- 바로, 트랜스포메이션과 액션! 

- 액션
 > - RDD가 아닌 것들을 Return
 > - 액션은 특정정보를 드라이버에 되돌려주거나, 데이터를 저장 장치에 기록해주기 때문에, 스파크에서는 반드시 액션이 있어야함
 > - 실제 연산을 실행하도록 강제
 > - persist 호출하는 것도 마찬가지 역할이지만.. 스파크 잡이 끝나는 것으로 간주하지 않음 ( 처음안 사실.. 약간 확인해볼필요있을 듯 )
 > - 하둡에 저장하는 대부분 액션들은 key/value를 가지는 RDD에만 사용할 수 있음 ( 근데, key/value 아니여도 잘 저장됌)
 > - PairRDDFunctions 클래스와 NewHadoopRDD 클래스에 정의되어 있음
 > - savaAsTextFile이나 savaAsObjectFile은 모든 RDD에서 사용가능한데, 암무적으로 null 키를 레코드에 추가해서 작동 ( key/value 아니여도 저장되는 이유 )

- 트랜스포메이션 
 > - 새로운 RDD를 Return
 > - 분산 데이터를 정렬, 리듀스, 샘플링, 필터링, 매핑하는데 쓰임
 > - 자세한 내용은 다음에~
 
 ### 넓은 종속성 VS 좁은 종속성
 
 - RDD가 어떻게 평가되는지 이해하기 위해서는 위 두가지 분류에 대해 알아야함
 - 좁은 종속성
 > - 자식 RDD의 각 파티션이 부모 RDD의 파티션들에 대해 단순하고 한정적인 종속성을 가지는 것 ( 아.. 추상적이다 )
 > 조건1) 디자인 시점에 종속성을 결정할 수 있어야함 ( = 디자인 시점에 알게된 부모 파티션들 중 알려진 일부에만 종속 ) = coalesce
 > 조건2) 부모 파티션의 값과 상관이 없으며
 > 조건3) 각각 부모가 최대 하나의 자식 파티션을 가진다
 
 > - 좁은 종속성의 트랜스포메이션은 부모 파티션에만 종속되거나 (map), 디자인 시점에 알게된 부모 파티션들 중 알려진 일부에만 종속 (coalesce)
 > - map = 파티션 간 데이터 이동이 없는 경우
 > - coalesce = 파티션을 합치기만 하므로, 둘 다 데이터의 내용을 알 필요가 없다.  
 > - 그러므로, 좁은 트랜스포메이션은 다른 파티션의 정보를 필요로 하지 않고 데이터의 임의의 부분에 대해 실행 가능 
 
 - 넓은 종속성
 > - 데이터의 임의의 데이터만으로 실행할 수는 없음
 > - sort같은 경우 같은 범위의 키들이 같은 파티션 안에 존재하도록 레코드들을 파티셔닝해야 한다. 
 
 특별한 경우, 데이터가 어떤 특정한 방법으로 파티션되어 있다는 것을 알고 있다면, 넓은 종속성 연산이라도 셔플링은 하지 않음
 - 어떤 연산이 실행을 위해 셔플링을 요구한다면, RDD의 종속성 목록에 ShuffledDependecncy 객체를 추가함 
 - 셔플링은 비싼 비용을 치루고, 셔플 과정에서 새로운 파티션으로 옮겨야 하는 데이터의 비율이 높을 수록 더 비싸진다.
 
 --- 
 
 정리해보자면, 좁은 종속성은 map, filter와 같이 다른 파티션과는 상관없이, 단순히 부모 RDD의 파티션에 대해서만 고려함 
 coalse같이 여러 부모의 파티션을 합치는 경우에는, 파티션 안에 있는 값에는 신경을 안씀,
 즉 데이터 내용을 볼 필요없으니깐 디자인 시점에 종속된다하고 좁은 족속성이라 칭함
 
 == 이 것에 대해서는 뒤에서 자세히 나오면 다시 정리할 것 !! ==
 
 
 
