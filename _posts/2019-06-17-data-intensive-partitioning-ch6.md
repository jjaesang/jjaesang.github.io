---
layout: post
title:  "[Data-Intensive] Ch6. 파티셔닝 (Partitioning)"
date: 2019-06-17 18:15:12
categories: Data-Intensive-Application 
author : Jaesang Lim˚
tag: Data-Intensive-Application 
cover: "/assets/instacode.png"
---

## 파티셔닝 
'데이터 중심 애플리케이션 설계'를 읽고 정리하고자함

- 대용량 데이터셋을 작은 데이터셋으로 파티셔닝하는 전략에 대해 설명 
> - 저장하고 처리할 데이터가 한대의 서버에서 처리하지 못할 시, 파티셔닝을 해야함

파티셔닝의 목적
1. 핫스팟이 생기지 않게 해야함
> - 불균형적으로 높은 부하를 받는 노드 = 핫스팟
2. 데이터와 질의 부하를 여러장비에 균등하게 분배해야함

그러기 위해서는 ?
- 데이터에 적합한 파티셔닝 방식을 선택해야함
- 노드가 추가/제거 될 때, 파티션 재균형화를 실행해야함 

파티셔닝 방법론 
1. 키 범위 파티셔닝
> - 키가 정렬돼 있고, 개별 파티션은 어떤 최솟값과 최댓값 사이에 속하는 모든 키를 담당함
> - 키가 정렬돼 있어 **범위 질의에 효과적**
> - 정렬 순서가 서로 가까운 키에 자주 접급하면 **핫스팟**이 생길 위험이 있음
> - 일반적으로, 한 파티션이 너무 크면 키범위를 두개로 쪼개  동적으로 재균형화를 실행함 

2. 해시 파티셔닝
> - 각 키에 해싱 함수 적용하고, 개별 파티션은 특정 범위의 해시값으 담당함
> - 키 순서가 보장되지 않아 **범위 질의에 비효율적**이지만, **부하를 균일하게 분산**할 수 있음
> - 보통 고정된 개수의 파티션을 미리 만들어 각 노드에 몇 개씩 파티션을 할당함
> - 노드가 추가/삭제되면 파티션을 통째로 노드사이에서 이동함
> - 동적 파티셔닝 적용 가능

두가지 방법을 섞어서 사용할 수 있음
- 키 일부분은 파티션 식별용으로, 나머지는 정렬용으로 복합키 설계 가능

파티셔닝과 보조 색인 사이의 상호작요 
1. 문서 파티셔닝 색인(지역 색인)
> - 보조 색인을 기본키와 값이 저장된 파티션에 저장
> - 쓸 때는 파티션 하나만 갱신하면 됨
> - 읽을 때는 모든 파티션에 걸쳐 [Scatter gather](https://kldp.org/node/81436)를 실행해야함

2. 용어 파티셔닝 색인(전역 색인)
> - 색인된 값을 사용해서 보조 색인을 별도로 파티셔닝
> - 보조 색인 항목은 기본키의 모든 파티션에 있는 레코드를 포함할 수 있음
> - 문서를 쓸 때는 여러개를 갱신해야함
> - 읽을 때는 단일 파티션에서 실행할 수 있음 

- 모든 파티션은 대부분 독립적으로 동작함
> - 그래서, 파티셔닝된 데이터베이스는 여러 장비에 확장할 수 있음 

- 하지만 여러 파티션에 기롣해야하는 연산은 ..?
- 예를 들어, 한 파티션에는 쓰기 성공했지만, 다른 파티션에서 실패하면..? 
- 이 문제는 다음 블로그, **트랜잭션**에서 다룰 예정

방금까지가 정리였고, 이제 **파티셔닝**에 대해 세세하게 알아봅시다~

---

## 파티셔닝

데이터 파티셔닝을 원하는 주된 이유 : **확장성**
- 대용량 데이터셋이 여러 디스크에 분산될 수 있고, 질의 부하는 여러 프로세스에서 분산될 수 있음


### 파티셔닝과 복제
![1](https://user-images.githubusercontent.com/12586821/59677741-8c6dab00-9205-11e9-8e19-9c4781307aa7.PNG)

- 보통 **복제**와 **파티셔닝**을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장
> - 각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 **내결함성**을 보장할 수 있음

- 한 노드에 여러 파티션을 저장할 수 있음
> - 위의 그림이 리더 팔로워 복제 모델에서의 파티셔닝과 복제의 모습
> - 각 파티션의 리더는 하나의 노드에 할당되고 팔로워들은 다른 노드에 할당
> - 각 노드는 어떤 파티션에서는 리더, 팔로워 일 수 있음 

---

### 키-값 데이터 파티셔닝

어떤 레코드를 어느 노드에 저장할지 어떻게 결정할 것 인가?

파티션의 목적 
- 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것 

쏠렸다(skewed) = 쏠린, 불균형하게 부하가 높은 파티션 = **핫스팟**
- 파티션이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션을 칭함

핫스팟을 피하는 방법
- 레코드를 할당할 노드를 무작위로 선책
> - 간단하게 고르게 분산된다는 장점 
> - 어떤 레코드를 읽으려면 해당 레코드가 어딨는지 몰라, 모든 노드에서 병렬적으로 질의를 수행해야함

#### 1. 키 범위 기준 파티셔닝

각 파티션에 연속된 범위(어떤 최솟값에서 최댓값까지)의 키를 할당하는 것 
> - 키 범위들 사이의 경께를 알면, 어떤 키가 어느 파티션에 속하는지 찾을 수있음 
> - 즉, 어떤 파티션이 어느 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있음
 
- 키 범위 크기가 반드시 동일할 필요없음

파티션 경계는 수동으로 선택하거나, 데이터베이스에서 자동을 선택되게 할 수 있음
> - 빅테이블, Hbase, RethinkDB , 2.6이전의 몽고DB 

키 파티션 내에서는 키로 정렬된 순서로 저장할 수 있음
> - 범위 스캔이 쉬어지고, 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드를 여러개 읽어올 수 있음

#### 2. 키의 해시값 기준 파티셔닝

쏠림과 핫스팟 위험으로 많은 분산 데이터스토어는 키의 파티션을 정하는데 **해시 함수** 사용

- 파티셔닝용 해시 함수는 암호적으로 강렬할 필요 없음
> - 카산드라, 몽고DB는 MD5
> - 볼드포트는 Fowler-Noll-Vo 함수 

- 프로그래밍 언어에 간단한 해시 테이블을 사용하는 해시 함수가 내장돼 있지만, 파티셔닝에는 적합하지 않을 수 있음
> - Object.hashCode() 는 같은 키를 넣어도 다른 프로세스에서는 다른 해시값을 반환할 수 있음 

![3](https://user-images.githubusercontent.com/12586821/59677742-8c6dab00-9205-11e9-8cb1-1f70e819cc1a.PNG)
키에 적합한 해시함수로 **각 파티션에 해시값 범위를 할당**하고 **해시값이 파티션의 범위에 속하는 모든 키**를 그 파티션에 할당


**일관성 해시**
> - CDN 같은 인터넷 규모의 캐시 시스템에서 부하를 균등하게 분산시키는 방법
> - 파티션 경계를 무작위로 선택
> - **일관성**은 재균형화 방법을 의미
> - 그냥 **해시 파티셔닝**오 같은 의미로 생각하자 
 
단점
- 범위 질의를 효율적으로 실행하기 어려움 
> - 인접했던 키들이 모든 파티션에 흩어져서 정렬 순서가 유지되지 않음 


#### 쏠린 작업부하와 핫스팟 완화

키를 해싱하면 핫스팟을 줄이는데 도움이 되지만, 완벽하게 제거할 수 없음
> - 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠림 

방법 

- 요청이 쏠린 키에 대해 임의의 숫자를 붙이는 것
> - 임의의 10진수 두개만 붙이더라도 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산되고, 그 키들은 다른 파티션으로 분산될 수 있음 
- 문제
> - 읽기를 실행할 때 추가적인 작업이 필요해짐 
> - 100개의 키에 해당하는 데이터르 읽어서 조합해야함

- 쓰기 처리량이 낮은 대대수의 키에도 적용하면 불필요한 오버헤드가 생김


---

### 파티셔닝과 보조 색인
#### 1. 문서 기분 보조 색인 파티셔닝

![4](https://user-images.githubusercontent.com/12586821/59677743-8d064180-9205-11e9-8f5c-38690196488c.PNG)
![5](https://user-images.githubusercontent.com/12586821/59677734-8bd51480-9205-11e9-8f49-55656f08cfcc.PNG)
#### 2. 용어 기준 보조 색인 파티셔닝

---

### 파티션 재균형화

#### 1. 해시값에 Mod N 연산 수행

#### 2. 파티션 개수 고정 
![6](https://user-images.githubusercontent.com/12586821/59677736-8bd51480-9205-11e9-81e1-12f1c7fd0c5b.PNG)

#### 3. 동적 파티셔닝

#### 4. 노드 비례 파티셔닝

#### 운영: 자동 재균형화와 수동 재균형화

---

### 요청 라우팅
![7](https://user-images.githubusercontent.com/12586821/59677739-8c6dab00-9205-11e9-8146-3959b28c2da8.PNG)

#### 병렬 질의 실행
![8](https://user-images.githubusercontent.com/12586821/59677740-8c6dab00-9205-11e9-8ef1-c1b4185dad7b.PNG)

